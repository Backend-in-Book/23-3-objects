# 8장 - 의존성 관리하기

- 스터디 중 삼색볼펜법으로 체크한 부분들을 팀원들과 공유한 내용입니다.
- 스터디원들이 2명 이상 겹치는 부분은 강조표시(BOLD) 되어 있습니다.
- 문장은 페이지의 오름차순으로 정렬되어 있습니다.

##  빨강 (아주 중요하다고 생각한 내용!)
- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.(253p)
- 객체지향 애플리케이션에서 런타임의 주인공은 객체다.(258p)
- 유연하고 재사용 가능한 설계를 창조하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.(259p)
- 설계가 유연해지기 위해서는 가능한 한 자신이 실행된 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.(261p)
- 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋다.(
  264p)
- 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.(265p)
- **다시 말해 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다는 것이다. 이것이 핵심이다.(268p)**
- 의존성은 명시적으로 표현되어야 한다.(271p)
- 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체 클래스가 아닌  추상 클래스에 의존하게 함으로써 설게를 유연하게 만들 수 있다.(274p)

##  파랑 (중요하다고 생각한 내용!)

- 작고 응집도 높은 객체란 책임의 초점이 명확하게 한가지 일만 잘하는 객체를 의미한다.(253p)
- 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있다.(253p)
- 의존성은 방향성을 가지며 항상 단방향이다.(254p)
- 의존성 전이는 변경에 의해 영향이 널리 전파될 수도 있따는 경고일 뿐이다.(257p)
- 직접 의존성이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다.(257p)
 간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가르킨다.(257p)
- 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.(257p)
- 사실 여기서 중요한 건 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것이다.(258p)
- 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.(258p)
- 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.(260p)
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.(260p)
- 문제는 의존성의 존재가 아니라 의존성의 정도다.(265p)
- 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.(261p)
- 이처럼 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.(261p)
- 따라서 모든 의존성이 나쁜 것은 아니다.(264p)
- 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도(loose coupling) 또는 약한 결합도(weak coupling)를 가진다고 말한다.(266p)
- 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)를 가진다고 말한다.(266p)
- **서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.(267p)**
- 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.(267p)
- 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.(268p)
- 의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라.(271p)
- new는 결합도를 높이기 떄문에 해롭다.(273p)
- 따라서 의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다.(276p)
- 따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.(276p)
- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.(281p)
- 훌륭한 객체지향 설계란 객체가 어떻게 하는 지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는 지를 표현하는 설계다.(281p)

##  초록 (흥미롭다고 생각한 내용!)

- UML은 두 요소 사이에 존재할 수 있는 다양한 관계의 하나로 '의존 관계'를 정의한다.(256p)
- 클래스가 다른 클래스에 의존하는 것은 부끄러운 일이 아니다.(271p)
- 숨겨져 있는 의존성을 밝은 곳으로 드러내서 널리 알려라.(271p)
