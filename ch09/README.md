# 9장 - 유연한 설계

- 스터디 중 삼색볼펜법으로 체크한 부분들을 팀원들과 공유한 내용입니다.
- 스터디원들이 2명 이상 겹치는 부분은 강조표시(BOLD) 되어 있습니다.
- 문장은 페이지의 오름차순으로 정렬되어 있습니다.

##  빨강 (아주 중요하다고 생각한 내용!)
- 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.(282p)
- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라(283p)
- 한 마디로 말해서 객체에 대한 생성과 사용을 분리해야한다.(288p)
- 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안되는 것이다.(301p)
- 유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러타임이 고수하는 의존성의 방향을 역전시킨다.(304p)
- 유연한 설계는 유연성이 필요할 때만 옳다(305p)

##  파랑 (중요하다고 생각한 내용!)

- 확장에 대해 열려있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작’을 추가해서 애플리케이션의 기능을 확장할 수 있다.(282p)
- 수정에 대해 닫혀있다: 기본의 ‘코드’를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.(282p)
- **개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.(284p)**
- 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.(284p)
- 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.(284p)
- 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다.(286p)
- **한 마디로 말해서 객체에 대한 생성과 사용을 분리해야한다.(288p)**
- 이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 Factory라고 부른다.(289p)
- 의존성 주입은 의존성을 명시적으로 명시할 수 있는 방법 중 하나일 뿐이다.(300p)
- 의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.(301p)
- 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같이 추상화를 따라야 한다.(301p)
- 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.(304p)
- 유연성은 항상 복잡성을 수반한다.(305p)
- 유연하지 않은 설계는 단순하고 명확하다.(305p)
- 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다(305p)
- 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.(305p)

##  초록 (흥미롭다고 생각한 내용!)
- 
