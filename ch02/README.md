# 2장 - 객체지향프로그래밍

- 스터디 중 삼색볼펜법으로 체크한 부분들을 팀원들과 공유한 내용입니다.
- 스터디원들이 2명 이상 겹치는 부분은 강조표시(BOLD)가 되어 있습니다.
- 문장은 페이지의 오름차순으로 정렬되어 있습니다.

## 🔴 빨강 (아주 중요하다고 생각한 내용!)
- 외부에서는 객체가 어떤 상태에 놓여 있는 지, 어떤 생각을 하고 있는지 알아서는 안되며, 결정에 직접적인 개입하려고 해서도 안된다. (44p)
- 객체에게 원하는 것을 요청하고는 객체가 스스로 최선의 방법을 결정할 수 있는 것이라는 점을 믿고 기다려야 한다. (44p)
- 인터페이스와 구현의 분리(separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다. (44p)
- 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있따면 객체를 사용해서 해당 개념을 구현하라. (47p)
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송(send a message)하는 것뿐이다. (49p)
- 이처럼 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다. (57p)
- 여러분이 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다. (59p)
- 다형성이란 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. (63p)
- 항상 에외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라. (67p)
- 고민하고 트레이드 오프하라. (69p)
- 이처럼 코드를 재사용하는 경우에는 상속보다는 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다. (72p)


## 🔵 파랑 (중요하다고 생각한 내용!) 
- 객체를 협력하는 공동체의 일원으로 바라는 것은 설게를 유연하고 확장 가능하게 만든다. (41p)
- 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다. (41p)
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다. (41p)
- 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부로 공개하고 어떤 부분을 감출지를 결정하는 것이다. (43p)
- 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다. (44p) 
- 설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라. (45p)
- 객체의 변경을 관리할 수 있는 기법 중 가장 대표적인 것이 바로 접근 제어다. (45p)
- 메세지를 수신한 객체는 스스로 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다. (49p)
- 이처럼 부모 클래스에서 기본적인 알고리즘을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 부른다. (52p)
- 여기서 이야기하고 싶은 것은 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다는 것이다.(2) (59p)
- 한 가지 간과해서는 안되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다. (59p)
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라. (59p)
- 이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍(programming by difference)이라고 부른다. (60p)
- 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메세지를 이해할 수 있어야 한다. (63p)
- 다시 말해 인터페이스가 동일해야 한다는 것이다. (63p)
- 따라서 책임의 위치를 결정하기 위해 조건문을 사용하는 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다. (67p)
- 상속의 가장 큰 문제점은 캡슐화를 위반한다는 것이다. (70p)
- 결과적적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다. (70p)
- 이처럼 인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다. (72p)
- 따라서 코드 재사용을 위해서는 상속보다는 합성을 선화는 것이 더 좋은 방법이다. (72p)

## 🟢 초록 (흥미롭다고 생각한 내용!)
- 비록 이번 장에서 다루는 프로그램이 객체지향 프로그래밍의 강력함을 느낄 수 있을 정도로 충분히 복잡하지는 않지만 매우 크고 복잡한 구조를 가진 시스템이라고 여러분 스스로에게 최면을 걸어주기 바란다. (37p) 
- 이처럼 생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할 수 있다. (56p)
- 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다. (59p)
- 재사용 가능한 설계의 기본을 이루는 디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문이다. (66p)


